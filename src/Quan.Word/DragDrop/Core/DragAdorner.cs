using System;
using System.Windows;
using System.Windows.Documents;
using System.Windows.Media;

namespace Quan.Word
{
    /// <summary>
    /// A drag adorner to display dragged item for giving user a better feedback
    /// </summary>
    internal class DragAdorner : Adorner
    {
        #region Private Members

        private readonly AdornerLayer m_AdornerLayer;
        private readonly UIElement m_Adornment;
        private Point m_MousePosition;

        #endregion

        #region Public Properties

        /// <summary>
        /// The translation transform to mouse point of this <see cref="DragAdorner"/>
        /// </summary>
        public Point Translation { get; private set; }

        /// <summary>
        /// The drag-and-drop effects of this <see cref="DragAdorner"/>
        /// </summary>
        public DragDropEffects Effects { get; private set; }

        /// <summary>
        /// The mouse position at drag-and-drop actions
        /// </summary>
        public Point MousePosition
        {
            get => m_MousePosition;
            set
            {
                if (m_MousePosition != value)
                {
                    m_MousePosition = value;
                    // Update layout of this adorner layer and redraws drag adorner
                    m_AdornerLayer.Update(AdornedElement);
                }
            }
        }

        #endregion

        #region Constructor

        /// <summary>
        /// Default constructor
        /// </summary>
        /// <param name="adornedElement">The root element of window to get a adorner layer</param>
        /// <param name="adornment">The content presenter element of this <see cref="DragAdorner"/></param>
        /// <param name="translation">The translation transform to mouse point of this <see cref="DragAdorner"/></param>
        /// <param name="effects">The drag-and-drop effects of this <see cref="DragAdorner"/></param>
        public DragAdorner(UIElement adornedElement, UIElement adornment, Point translation, DragDropEffects effects = DragDropEffects.None)
            : base(adornedElement)
        {
            Translation = translation;
            // An adorner layer is guaranteed to be at higher Z-order than the element being adorned
            // so adorners are always rendered on top of the adorned element
            m_AdornerLayer = AdornerLayer.GetAdornerLayer(adornedElement);
            if (m_AdornerLayer == null) throw new NullReferenceException("Can't find AdornerLayer on your app window, try to add it to your custom window");
            m_AdornerLayer?.Add(this);
            m_Adornment = adornment;
            IsHitTestVisible = false;
            Effects = effects;
        }

        #endregion

        #region Layout Processing

        /// <summary>
        /// The number of child elements for the <see cref="DragAdorner"/>
        /// </summary>
        protected override int VisualChildrenCount => 1;

        /// <summary>
        /// By default, a Visual has no children,
        /// so set child visual to this <see cref="DragAdorner"/>
        /// </summary>
        /// <param name="index">The index of the visual object</param>
        /// <returns></returns>
        protected override Visual GetVisualChild(int index)
        {
            return m_Adornment;
        }

        /// <summary>
        /// Evaluates <see cref="AdornerDecorator"/> element's child collection during the measure pass.
        /// First, evaluates native size properties of the element, such as Clip and Visibility
        /// Secondly, describe the sizing characteristics of the underlying UIElement.
        /// The ultimate goal of the measure pass is for the child to determine its desiredSize
        /// </summary>
        /// <param name="constraint">The available size</param>
        /// <remarks>
        /// see https://docs.microsoft.com/en-us/dotnet/api/system.windows.frameworkelement.measureoverride?view=netframework-4.8
        /// </remarks>
        /// <returns></returns>
        protected override Size MeasureOverride(Size constraint)
        {
            // Measure child element of this drag adorner
            m_Adornment.Measure(constraint);
            // Return desired size, cause we only have one element
            return m_Adornment.DesiredSize;
        }

        /// <summary>
        /// Generates final size of the child and puts the child within its layout slot
        /// then return to the parent <see cref="AdornerDecorator"/> and the layout process complete.
        /// </summary>
        /// <param name="finalSize">The arrangeSize generated by ArrangeCore Method</param>
        /// <returns></returns>
        protected override Size ArrangeOverride(Size finalSize)
        {
            // Arrange child element and pass final size to ensure child elements will be rendered
            m_Adornment.Arrange(new Rect(finalSize));
            return finalSize;
        }

        /// <summary>
        /// Called by the associated <see cref="AdornerLayer"/> to provide an opportunity to
        /// filter unwanted or unneeded transforms.
        /// </summary>
        /// <param name="transform">The transform that is currently applied to the adorned element</param>
        /// <returns></returns>
        public override GeneralTransform GetDesiredTransform(GeneralTransform transform)
        {
            var result = new GeneralTransformGroup();

            // Add default transform
            result.Children.Add(base.GetDesiredTransform(transform));

            // Translate drag adorner transform using DragAdornerTranslation
            result.Children.Add(new TranslateTransform(MousePosition.X + Translation.X, MousePosition.Y + Translation.Y));

            return result;
        }

        #endregion

        #region Methods

        /// <summary>
        /// Moves adorner following with mouse point
        /// </summary>
        /// <param name="newAdornerPosition">The new Adorner position comes from mouse position</param>
        /// <param name="anchorPoint">The horizontal and vertical proportion at which the pointer will anchor on the DragAdorner</param>
        /// <param name="adornerMousePosition">The last position</param>
        /// <param name="adornerSize">The last size of adorner</param>
        internal void Move(Point newAdornerPosition, Point anchorPoint, ref Point adornerMousePosition, ref Size adornerSize)
        {
            if (newAdornerPosition.X >= 0 && newAdornerPosition.Y >= 0)
            {
                adornerMousePosition = newAdornerPosition;
            }

            if (RenderSize.Width > 0 && RenderSize.Height > 0)
            {
                adornerSize = RenderSize;
            }

            var offsetX = adornerSize.Width * -anchorPoint.X;
            var offsetY = adornerSize.Height * -anchorPoint.Y;

            // Set an offset, let adorner to display separately with mouse cursor
            adornerMousePosition.Offset(offsetX, offsetY);

            if (adornerMousePosition.X < 0)
            {
                adornerMousePosition.X = 0;
            }
            else
            {
                var maxAdornerPosX = AdornedElement.RenderSize.Width;
                var adornerPosRightX = (adornerMousePosition.X + Translation.X + adornerSize.Width);
                if (adornerPosRightX > maxAdornerPosX)
                {
                    adornerMousePosition.Offset(-adornerPosRightX + maxAdornerPosX, 0);
                }
            }

            if (adornerMousePosition.Y < 0)
            {
                adornerMousePosition.Y = 0;
            }
            else
            {
                var maxAdornerPosY = AdornedElement.RenderSize.Height;
                var adornerPosRightY = (adornerMousePosition.Y + Translation.Y + adornerSize.Height);
                if (adornerPosRightY > maxAdornerPosY)
                {
                    adornerMousePosition.Offset(0, -adornerPosRightY + maxAdornerPosY);
                }
            }

            // Update layout of adorner
            MousePosition = adornerMousePosition;

            // Forces a complete new layout redraw of the adorner
            InvalidateVisual();
        }

        /// <summary>
        /// Clear the <see cref="AdornerLayer"/>
        /// </summary>
        public void Detach()
        {
            m_AdornerLayer.Remove(this);
        }

        #endregion
    }
}
